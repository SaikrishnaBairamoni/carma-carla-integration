#!/usr/bin/env python
#
# Copyright (c) 2020 Intel Corporation
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.
"""
ground truth detections. Publishes the following topics:
    /environment/external_objects  (cav_msgs::ExternalObjectList)
"""
import rospy
import tf

from derived_object_msgs.msg import ObjectArray, Object
from cav_msgs.msg import ExternalObjectList, ExternalObject

pub = rospy.Publisher('/environment/external_objects', ExternalObjectList, queue_size=1)

def converter(object):
    """
    CARLA object message type:
        derived_object_msgs::Object
    """
    object_type_lookup = {Object.CLASSIFICATION_PEDESTRIAN:ExternalObject.PEDESTRIAN,
                          Object.CLASSIFICATION_CAR:ExternalObject.SMALL_VEHICLE,
                          Object.CLASSIFICATION_TRUCK:ExternalObject.LARGE_VEHICLE,
                          Object.CLASSIFICATION_MOTORCYCLE:ExternalObject.MOTORCYCLE}

    ## CARMA external object init
    object_msg = ExternalObject()
    ## In the simulation source, the presence_vector should be a constant (except the object type)
    object_msg.presence_vector = object_msg.presence_vector + \
                                 ExternalObject.ID_PRESENCE_VECTOR + \
                                 ExternalObject.POSE_PRESENCE_VECTOR + \
                                 ExternalObject.VELOCITY_PRESENCE_VECTOR + \
                                 ExternalObject.SIZE_PRESENCE_VECTOR + \
                                 ExternalObject.CONFIDENCE_PRESENCE_VECTOR + \
                                 ExternalObject.DYNAMIC_OBJ_PRESENCE + \
                                 ExternalObject.OBJECT_TYPE_PRESENCE_VECTOR

    object_msg.header = object.header
    object_msg.id = object.id
    object_msg.pose.pose = object.pose
    object_msg.velocity.twist = object.twist

    ## since we are using simulation, the external objects info is not received via detector. The confidence should always be 1
    object_msg.confidence = 1

    ## object size convert
    object_msg.size.x = object.shape.dimensions[0]
    object_msg.size.y = object.shape.dimensions[1]
    object_msg.size.z = object.shape.dimensions[2]

    ## determine the vehicle is dynmic or static, 1: dynamic 2:static
    if object.twist.linear.x !=0 or \
        object.twist.linear.y !=0 or \
        object.twist.linear.z !=0:
        object_msg.dynamic_obj = 1
    else:
        object_msg.dynamic_obj = 0

    ## determine what objet type is
    if object.object_classified:
        if object.classification in object_type_lookup:
            object_msg.object_type = object_type_lookup[object.classification]
        else:
            object_msg.object_type = ExternalObject.UNKNOWN
    else:
        ## if the object classified is set as False, it means the object can not be identified
        object_msg.presence_vector = object_msg.presence_vector - ExternalObject.OBJECT_TYPE_PRESENCE_VECTOR

    return object_msg

def external_objects_callback(obj_arr):
    """
    callback current objects
    obj_arr message type:
        derived_object_msgs::ObjectArray
    """
    objects_msg = ExternalObjectList()
    objects_msg.header = obj_arr.header
    for i in range(len(obj_arr.objects)):
        objects_msg.objects.append(converter(obj_arr.objects[i]))
    pub.publish(objects_msg)


def convert_objects():
    """
    main loop
    """
    rospy.init_node('carla_to_carma_external_objects', anonymous=True)
    role_name = rospy.get_param('/role_name', 'ego_vehicle')
    rospy.Subscriber('/carla/{}/objects'.format(role_name), ObjectArray, external_objects_callback)
    rospy.spin()


if __name__ == '__main__':
    print("carla_to_carma_external_objects")
    convert_objects()
